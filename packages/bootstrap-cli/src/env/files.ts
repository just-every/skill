import type { BaseEnv, BootstrapEnv, GeneratedEnv } from '../env.js';
import type { LogtoProvisionResult } from '../providers/logto.js';
import type { StripeProvisionResult } from '../providers/stripe.js';

export interface GenerateFilesResult {
  generatedEnvContents: string;
  devVarsContents: string;
}

export interface GenerateFilesOptions {
  base: BaseEnv;
  generated: GeneratedEnv;
  logtoResult?: LogtoProvisionResult;
  stripeResult?: StripeProvisionResult;
}

const GENERATED_ENV_HEADER = [
  '# Autogenerated by bootstrap CLI',
  '# Do not edit manually â€“ rerun `pnpm bootstrap:env` instead.',
  ''
].join('\n');

const DEV_VARS_HEADER = [
  '# Autogenerated by bootstrap CLI',
  '# Keep secrets here for local wrangler dev; do not commit real production secrets.',
  ''
].join('\n');

export function buildGeneratedFiles(options: GenerateFilesOptions): GenerateFilesResult {
  const { base, generated, logtoResult, stripeResult } = options;
  const env: BootstrapEnv = {
    ...base,
    ...generated
  };

  const webEntries: Array<[string, string]> = [];
  const workerEntries: Array<[string, string]> = [];

  pushWeb(webEntries, 'PROJECT_ID', env.PROJECT_ID);
  pushWeb(webEntries, 'PROJECT_DOMAIN', env.PROJECT_DOMAIN ?? '');
  const projectHost = deriveProjectHost(env.PROJECT_DOMAIN);
  const appUrl = deriveAppUrl(env);
  const appBaseUrl = deriveAppBaseUrl(env);
  pushWeb(webEntries, 'PROJECT_HOST', projectHost);
  pushWeb(webEntries, 'APP_URL', appUrl);
  pushWeb(webEntries, 'APP_BASE_URL', appBaseUrl);

  // Use Logto result if available, otherwise fall back to env
  const logtoAppId = logtoResult?.applicationId ?? env.LOGTO_APPLICATION_ID ?? '';
  const logtoAppSecret = logtoResult?.applicationSecret ?? env.LOGTO_APPLICATION_SECRET ?? '';
  const logtoApiResourceId = logtoResult?.apiResourceId ?? '';
  const logtoM2MAppId = logtoResult?.m2mApplicationId ?? '';
  const logtoM2MSecret = logtoResult?.m2mApplicationSecret ?? '';

  const logtoEndpoint = env.LOGTO_ENDPOINT ?? '';
  const canonicalOrigin = deriveCanonicalOrigin(env);
  const workerOrigin = deriveWorkerOrigin(env, appUrl);
  const localOrigin = deriveLocalOrigin(env);
  const prodRedirectUri = `${canonicalOrigin}/callback`;
  const localRedirectUri = `${localOrigin}/callback`;

  pushWeb(webEntries, 'LOGTO_ENDPOINT', logtoEndpoint);
  pushWeb(webEntries, 'LOGTO_APPLICATION_ID', logtoAppId);
  if (logtoAppSecret) {
    pushWeb(webEntries, 'LOGTO_APPLICATION_SECRET', logtoAppSecret);
  }
  pushWeb(webEntries, 'LOGTO_API_RESOURCE', env.LOGTO_API_RESOURCE);
  pushWeb(webEntries, 'LOGTO_API_RESOURCE_ID', env.LOGTO_API_RESOURCE_ID ?? '');

  const issuer = env.LOGTO_ISSUER ?? `${trimTrailingSlash(logtoEndpoint)}/oidc`;
  const jwksUri = env.LOGTO_JWKS_URI ?? `${trimTrailingSlash(logtoEndpoint)}/oidc/jwks`;
  pushWeb(webEntries, 'LOGTO_ISSUER', issuer);
  pushWeb(webEntries, 'LOGTO_JWKS_URI', jwksUri);

  pushWeb(webEntries, 'EXPO_PUBLIC_LOGTO_ENDPOINT', logtoEndpoint);
  pushWeb(webEntries, 'EXPO_PUBLIC_LOGTO_APP_ID', logtoAppId);
  pushWeb(webEntries, 'EXPO_PUBLIC_API_RESOURCE', env.LOGTO_API_RESOURCE);
  pushWeb(webEntries, 'EXPO_PUBLIC_LOGTO_REDIRECT_URI_LOCAL', localRedirectUri);
  pushWeb(webEntries, 'EXPO_PUBLIC_LOGTO_REDIRECT_URI_PROD', prodRedirectUri);
  pushWeb(webEntries, 'EXPO_PUBLIC_LOGTO_REDIRECT_URI', prodRedirectUri);
  pushWeb(webEntries, 'EXPO_PUBLIC_LOGTO_SCOPES', 'openid offline_access profile email');
  pushWeb(webEntries, 'EXPO_PUBLIC_LOGTO_RESOURCES', env.LOGTO_API_RESOURCE);
  pushWeb(
    webEntries,
    'EXPO_PUBLIC_LOGTO_POST_LOGOUT_REDIRECT_URI',
    env.EXPO_PUBLIC_LOGTO_POST_LOGOUT_REDIRECT_URI ?? canonicalOrigin
  );
  pushWeb(webEntries, 'EXPO_PUBLIC_WORKER_ORIGIN', workerOrigin);
  pushWeb(webEntries, 'EXPO_PUBLIC_WORKER_ORIGIN_LOCAL', localOrigin);

  const d1Name = env.CLOUDFLARE_D1_NAME ?? `${env.PROJECT_ID}-d1`;
  const d1Id = env.D1_DATABASE_ID ?? env.CLOUDFLARE_D1_ID ?? '';
  const r2Bucket = env.CLOUDFLARE_R2_BUCKET ?? `${env.PROJECT_ID}-assets`;
  pushWeb(webEntries, 'CLOUDFLARE_D1_NAME', d1Name);
  pushWeb(webEntries, 'CLOUDFLARE_D1_ID', env.CLOUDFLARE_D1_ID ?? '');
  pushWeb(webEntries, 'D1_DATABASE_NAME', d1Name);
  pushWeb(webEntries, 'D1_DATABASE_ID', d1Id);
  pushWeb(webEntries, 'CLOUDFLARE_R2_BUCKET', r2Bucket);
  pushWeb(webEntries, 'R2_BUCKET_NAME', r2Bucket);
  pushWeb(webEntries, 'CLOUDFLARE_ZONE_ID', env.CLOUDFLARE_ZONE_ID ?? '');

  // Use Stripe result if available, otherwise fall back to env
  const stripeWebhookSecret =
    stripeResult?.webhook?.webhookSecret ?? env.STRIPE_WEBHOOK_SECRET ?? '';
  const stripeProductIds = stripeResult?.products
    ? stripeResult.products.map((p) => p.productId).join(',')
    : env.STRIPE_PRODUCT_IDS ?? '';
  const stripePriceIds = stripeResult?.products
    ? stripeResult.products.flatMap((p) => p.priceIds).join(',')
    : env.STRIPE_PRICE_IDS ?? '';
  const stripeWebhookUrl = stripeResult?.webhook?.url ?? env.STRIPE_WEBHOOK_URL ?? '';

  pushWeb(webEntries, 'STRIPE_WEBHOOK_SECRET', stripeWebhookSecret);
  pushWeb(webEntries, 'STRIPE_WEBHOOK_URL', stripeWebhookUrl);
  pushWeb(webEntries, 'STRIPE_PRODUCT_IDS', stripeProductIds);
  pushWeb(webEntries, 'STRIPE_PRICE_IDS', stripePriceIds);
  pushWeb(webEntries, 'STRIPE_PRODUCTS', env.STRIPE_PRODUCTS ?? '');

  // Add Logto M2M credentials for smoke tests
  if (logtoM2MAppId) {
    pushWeb(webEntries, 'LOGTO_M2M_APP_ID', logtoM2MAppId);
  }
  if (logtoM2MSecret) {
    pushWeb(webEntries, 'LOGTO_M2M_APP_SECRET', logtoM2MSecret);
  }

  pushWorker(workerEntries, 'LOGTO_APPLICATION_ID', logtoAppId);
  if (logtoAppSecret) {
    pushWorker(workerEntries, 'LOGTO_APPLICATION_SECRET', logtoAppSecret);
  }
  pushWorker(workerEntries, 'LOGTO_API_RESOURCE', env.LOGTO_API_RESOURCE);
  pushWorker(workerEntries, 'LOGTO_API_RESOURCE_ID', env.LOGTO_API_RESOURCE_ID ?? '');
  pushWorker(workerEntries, 'LOGTO_ISSUER', issuer);
  pushWorker(workerEntries, 'LOGTO_JWKS_URI', jwksUri);
  pushWorker(workerEntries, 'CLOUDFLARE_R2_BUCKET', r2Bucket);
  pushWorker(workerEntries, 'STRIPE_SECRET_KEY', env.STRIPE_SECRET_KEY);
  pushWorker(workerEntries, 'STRIPE_WEBHOOK_SECRET', stripeWebhookSecret);

  const generatedEnvContents = GENERATED_ENV_HEADER + formatKeyValueBlock(webEntries);
  const devVarsContents = DEV_VARS_HEADER + formatKeyValueBlock(workerEntries);

  return {
    generatedEnvContents,
    devVarsContents
  };
}

function pushWeb(target: Array<[string, string]>, key: string, value: string): void {
  target.push([key, value ?? '']);
}

function pushWorker(target: Array<[string, string]>, key: string, value: string): void {
  target.push([key, value ?? '']);
}

function formatKeyValueBlock(entries: Array<[string, string]>): string {
  return entries
    .map(([key, value]) => `${key}=${escapeValue(value)}`)
    .join('\n');
}

function escapeValue(value: string): string {
  if (value === '') return '';
  if (/^[A-Za-z0-9_./:-]+$/.test(value)) {
    return value;
  }
  return JSON.stringify(value);
}

function deriveProjectHost(domain?: string): string {
  if (!domain) return '';
  const withoutScheme = domain.replace(/^https?:\/\//, '');
  return withoutScheme.split('/')[0].split(':')[0];
}

function deriveAppBaseUrl(env: BootstrapEnv): string {
  return env.APP_BASE_URL ?? '/app';
}

function deriveAppUrl(env: BootstrapEnv): string {
  if (env.APP_URL) return env.APP_URL;
  if (env.PROJECT_DOMAIN) {
    const trimmed = trimTrailingSlash(env.PROJECT_DOMAIN);
    return `${trimmed}${deriveAppBaseUrl(env)}`;
  }
  return '/app';
}

function deriveWorkerOrigin(env: BootstrapEnv, resolvedAppUrl: string): string {
  if (env.WORKER_ORIGIN) return env.WORKER_ORIGIN;
  if (resolvedAppUrl) return originFromUrl(resolvedAppUrl);
  if (env.PROJECT_DOMAIN) return originFromUrl(env.PROJECT_DOMAIN);
  return '';
}

function deriveCanonicalOrigin(env: BootstrapEnv): string {
  if (env.PROJECT_DOMAIN) {
    return originFromUrl(env.PROJECT_DOMAIN);
  }
  return `https://${env.PROJECT_ID}.justevery.com`;
}

function deriveLocalOrigin(env: BootstrapEnv): string {
  const candidate = env.EXPO_PUBLIC_WORKER_ORIGIN_LOCAL ?? 'http://127.0.0.1:8787';
  const normalised = originFromUrl(candidate);
  return normalised || 'http://127.0.0.1:8787';
}

function originFromUrl(url: string): string {
  const trimmed = trimTrailingSlash(url);
  if (!/^https?:/i.test(trimmed)) {
    return trimmed;
  }
  try {
    const parsed = new URL(trimmed);
    return `${parsed.protocol}//${parsed.host}`;
  } catch {
    return trimmed;
  }
}

function trimTrailingSlash(value: string): string {
  return value.replace(/\/$/, '');
}
